/// @title  Staking
/// @notice SPDX-License-Identifier: MIT
/// @author takez0_o <https://github.com/takez0o>
/// @author 
/// @notice Modern and gas efficient implementation of StakingRewards algorithm
/// @notice Adapted from Synthetix (https://github.com/Synthetixio/synthetix/blob/develop/contracts/StakingRewards.sol)
/// @notice Inspired by HuffMate (https://github.com/pentagonxyz/huffmate)

// Imports
#include "huffmate/auth/NonPayable.huff"
#include "huffmate/auth/Owned.huff"
#include "huffmate/data-structures/Hashmap.huff"
#include "huffmate/math/SafeMath.huff"
#include "huffmate/tokens/ERC20.huff"
#include "huffmate/utils/Errors.huff"
#include "huffmate/utils/ReentrancyGuard.huff"

// Events
#define event RewardAdded(uint256)
#define event Staked(address indexed, uint256)
#define event Withdrawn(address indexed, uint256)
#define event RewardPaid(address indexed, uint256)
#define event RewardsDurationUpdated(uint256)
#define event Recovered(address, uint256)

// Interface
#define function totalSupply() view returns(uint256)
#define function balanceOf(address) view returns (uint256)
#define function lastTimeRewardApplicable() view returns (uint256)
#define function rewardPerToken() view returns (uint256)
#define function earned(address) view returns (uint256)
#define function getRewardForDuration() view returns (uint256)
#define function stake(uint256) nonpayable returns () 
#define function withdraw(uint256) nonpayable returns () 
#define function getReward() nonpayable returns ()
#define function exit() nonpayable returns () 
#define function notifyRewardAmount(uint256) nonpayable returns ()
#define function recoverERC20(address,uint256) nonpayable returns ()
#define function setRewardsDuration(uint256) nonpayable returns ()

// Storage
#define constant REWARDS_TOKEN_SLOT = FREE_STORAGE_POINTER()
#define constant STAKING_TOKEN_SLOT = FREE_STORAGE_POINTER()
#define constant PERIOD_FINISH_SLOT = FREE_STORAGE_POINTER()
#define constant REWARD_RATE_SLOT = FREE_STORAGE_POINTER()
#define constant REWARDS_DURATION_SLOT = FREE_STORAGE_POINTER()
#define constant LAST_UPDATE_TIME_SLOT = FREE_STORAGE_POINTER()
#define constant REWARD_PER_TOKEN_STORED_SLOT = FREE_STORAGE_POINTER()
#define constant USER_REWARD_PER_TOKEN_PAID_SLOT = FREE_STORAGE_POINTER()
#define constant REWARDS_SLOT = FREE_STORAGE_POINTER()
#define constant TOTAL_SUPPLY_SLOT = FREE_STORAGE_POINTER()
#define constant BALANCES_SLOT = FREE_STORAGE_POINTER()

// Utility Constants
#define constant UINT_256_MAX = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
#define constant DECIMAL = 0xDE0B6B3A7640000
#define constant ZERO_ADDRESS = 0x0000000000000000000000000000000000000000

/// @notice Constructor
/// @notice Sets the initial addresses
#define macro STAKING_CONSTRUCTOR() = takes (0) returns (0) {}

/// >>>>>>>>>>>>>>>>>>>>>  VIEW FUNCTIONS  <<<<<<<<<<<<<<<<<<<<<< ///

/// @notice Total Supply
/// @notice Returns the total token supply of the contract
#define macro TOTAL_SUPPLY() = takes (0) returns (0) {
    NON_PAYABLE()                       // []
    [TOTAL_SUPPLY_SLOT] sload           // [supply]
    0x00 mstore                         // []
    0x20 0x00 return                    // []
}

/// @notice Balance Of
/// @notice Returns the balance of the given address
#define macro BALANCE_OF() = takes (0) returns (0) {
    NON_PAYABLE()                                       // []
    0x04 calldataload                                   // [account]
    [BALANCES_SLOT] LOAD_ELEMENT_FROM_KEYS(0x00)        // [balance]
    0x00 mstore                                         // []
    0x20 0x00 return                                    // []
}

/// @notice Last Time Reward Applicable
/// @notice Returns the last time reward was applicable
#define macro LAST_TIME_REWARD_APPLICABLE() = takes (0) returns (0) {
    timestamp                       // [now]
    [PERIOD_FINISH_SLOT] sload      // [now, periodFinish]
    dup2 dup2                       // [now, periodFinish, now, periodFinish]
    lt                              // [now < periodFinish, now, periodFinish]

    periodFinishJump jumpi          // [now, periodFinish]
    0x00 mstore                     // [periodFinish]
    pop                             // []
    0x20 0x00 return                // []

    periodFinishJump:               // [now, periodFinish]
    pop                             // [periodFinish]
    0x00 mstore                     // []
    0x20 0x00 return                // []
}


/// @notice Reward Per Token
/// @notice Returns the reward per token
#define macro REWARD_PER_TOKEN() = takes (0) returns (0) {
    NON_PAYABLE()                                   // []
    [REWARD_PER_TOKEN_STORED_SLOT] sload            // [rewardPerTokenStored]
    [TOTAL_SUPPLY_SLOT] sload                       // [totalSupply, rewardPerTokenStored]
    dup1                                            // [totalSupply, totalSupply, rewardPerTokenStored]
    0x00 eq                                         // [totalSupply == 0, totalSupply, rewardPerTokenStored]
    
    totalSupplyJump jumpi                           // [totalSupply, rewardPerTokenStored]

    LAST_TIME_REWARD_APPLICABLE()                   // [lastTimeRewardApplicable, totalSupply, rewardPerTokenStored]
    [LAST_UPDATE_TIME_SLOT] sload                   // [lastUpdateTime, lastTimeRewardApplicable, totalSupply, rewardPerTokenStored ]
    SAFE_SUB()                                      // [lastUpdateTime - lastTimeRewardApplicable, totalSupply, rewardPerTokenStored]
    [REWARD_RATE_SLOT] sload                        // [rewardRate, lastUpdateTime - lastTimeRewardApplicable, totalSupply, rewardPerTokenStored]
    SAFE_MUL()                                      // [rewardRate * (lastUpdateTime - lastTimeRewardApplicable), totalSupply, rewardPerTokenStored]
    [DECIMAL] SAFE_MUL()                            // [rewardRate * (lastUpdateTime - lastTimeRewardApplicable) * DECIMAL, totalSupply, rewardPerTokenStored]
    SAFE_DIV()                                      // [rewardRate * (lastUpdateTime - lastTimeRewardApplicable) * DECIMAL / totalSupply, rewardPerTokenStored]
    SAFE_ADD()                                      // [rewardPerTokenStored + rewardRate * (lastUpdateTime - lastTimeRewardApplicable) * DECIMAL / totalSupply]

    0x00 mstore                                     // []
    0x20 0x00 return                                // []

    totalSupplyJump:                                // [totalSupply, rewardPerTokenStored]
    pop 0x00 mstore                                 // []
    0x20 0x00 return                                // []
}

/// @notice Earned
/// @notice Returns the amount of rewards earned by the given address
/// @param account The address of the account
#define macro EARNED() = takes (0) returns (1) {
    0x04 calldataload                               // [account]
    EARNED_INNER()                                  // [earned]
    0x00 mstore                                     // []
    0x20 0x00 return                                // []
}

/// @notice Earned Inner
/// @notice Returns the amount of rewards earned by the given address
#define macro EARNED_INNER() = takes (1) returns (1) {
    // input stack: [account]
    // output stack: [earned]
    NON_PAYABLE()                                                   // []
    0x04 calldataload                                               // [account]
    dup1                                                            // [account, account] 
    [USER_REWARD_PER_TOKEN_PAID_SLOT] LOAD_ELEMENT_FROM_KEYS(0x00)  // [userRewardPerTokenPaid, account]
    REWARD_PER_TOKEN()                                              // [rewardPerToken, userRewardPerTokenPaid, account]
    SAFE_SUB()                                                      // [rewardPerToken - userRewardPerTokenPaid, account]
    dup2                                                            // [account, rewardPerToken - userRewardPerTokenPaid, account]
    [BALANCES_SLOT] LOAD_ELEMENT_FROM_KEYS(0x00)                    // [balance, rewardPerToken - userRewardPerTokenPaid, account, account]
    SAFE_MUL()                                                      // [balance * (rewardPerToken - userRewardPerTokenPaid), account]
    [DECIMAL] SAFE_MUL()                                            // [balance * (rewardPerToken - userRewardPerTokenPaid) * DECIMAL, account]
    dup2                                                            // [account, balance * (rewardPerToken - userRewardPerTokenPaid) * DECIMAL, account]
    [REWARDS_SLOT] LOAD_ELEMENT_FROM_KEYS(0x00)                     // [rewards, balance * (rewardPerToken - userRewardPerTokenPaid) * DECIMAL, account]
    SAFE_ADD()                                                      // [rewards + balance * (rewardPerToken - userRewardPerTokenPaid) * DECIMAL, account]
    0x00 mstore                                                     // [account]
    pop                                                             // []
    0x20 0x00 return                                                // []
}

/// @notice Get Reward For Duration
/// @notice Returns the reward for the given duration
#define macro GET_REWARD_FOR_DURATION() = takes (0) returns (0) {
    NON_PAYABLE()                                   // []
    [REWARD_RATE_SLOT] sload                        // [rewardRate]
    [DURATION_SLOT] sload                           // [duration, rewardRate]
    SAFE_MUL()                                      // [duration * rewardRate]
    0x00 mstore                                     // []
    0x20 0x00 return                                // []
}

/// @notice Stake
/// @notice Stakes the given amount of tokens
#define macro STAKE() = takes (0) returns (0) {
    NON_PAYABLE()               // []
    caller                      // [caller]
    UPDATE_REWARD_INNER()       // []


}

#define macro UPDATE_REWARD() = takes (0) returns (0) {
    0x04 calldataload          // [account]
    UPDATE_REWARD_INNER()      // []
}

#define macro UPDATE_REWARD_INNER() = takes (1) returns (0) {
    // input stack: [account]
    // output stack: []
    [ZERO_ADDRESS] sload                                            // [zeroAddress, caller]
    dup2 eq                                                         // [zeroAddress == caller, caller]

    zeroAddressJump jumpi                                           // [caller]

    dup1                                                            // [caller, caller]
    EARNED_INNER()                                                  // [earned, caller]
    dup2                                                            // [caller, earned, caller]
    [REWARDS_SLOT] STORE_ELEMENT_FROM_KEYS(0x00)                    // [caller]
    [REWARD_PER_TOKEN_STORED_SLOT] sload                            // [rewardPerTokenStored, caller]
    [USER_REWARD_PER_TOKEN_PAID_SLOT] STORE_ELEMENT_FROM_KEYS(0x00) // []

    zeroAddressJump:                                                // [caller]
    pop                                                             // []
}

/// @notice Recover ERC-20
/// @notice Non-Payable function that transfers the given token in given amount to the owner.
#define macro RECOVER_ERC20() = takes (0) returns (0) {
    NON_PAYABLE()
    IS_OWNER()
    
    // Setup the stack for the transfer function.
    0x00 0x00 0x20 0x00         // [argsOffset, argsSize, retOffset, retSize]
    0x00 0x04 calldataload      // [address, value, argsOffset, argsSize, retOffset, retSize]
    0x24 calldataload           // [amount, address, value, argsOffset, argsSize, retOffset, retSize]
    0x00 mstore                 // [address, value, argsOffset, argsSize, retOffset, retSize]
    gas                         // [gas, address, value, argsOffset, argsSize, retOffset, retSize]
    call                        // [success]

    emitEventJump jumpi
    0x00 0x00 revert

    emitEventJump:
    // Emit the recovered event.
    0x24 calldataload           // [amount]
    0x04 calldataload           // [address, amount]
    __EVENT_HASH(Recovered)     // [sig, address, amount]
    dup1 0x00 mstore            // [sig, address, amount]
    0x20 0x00                   // [0, 32, sig, address, amount]
    log3                        // []

    // Return "1" to represent a successful transfer.
    0x01 0x00 mstore            // []
    0x20 0x00 return            // []
}

// Function Dispatching
#define macro MAIN() = takes (0) returns (0) {

    0x00 calldataload 0xE0 shr

    dup1 __FUNC_SIG(totalSupply)                eq totalSupplyJump                  jumpi
    dup1 __FUNC_SIG(balanceOf)                  eq balanceOfJump                    jumpi
    dup1 __FUNC_SIG(lastTimeRewardApplicable)   eq lastTimeRewardApplicableJump     jumpi
    dup1 __FUNC_SIG(rewardPerToken)             eq rewardPerTokenJump               jumpi
    dup1 __FUNC_SIG(earned)                     eq earnedJump                       jumpi
    dup1 __FUNC_SIG(getRewardForDuration)       eq getRewardForDurationJump         jumpi
    // dup1 __FUNC_SIG(stake)                      eq stakeJump                        jumpi
    // dup1 __FUNC_SIG(withdraw)                   eq withdrawJump                     jumpi
    // dup1 __FUNC_SIG(getReward)                  eq getRewardJump                    jumpi
    // dup1 __FUNC_SIG(exit)                       eq exitJump                         jumpi
    // dup1 __FUNC_SIG(notifyRewardAmount)         eq notifyRewardAmountJump           jumpi
    dup1 __FUNC_SIG(recoverERC20)               eq recoverERC20Jump                 jumpi
    // dup1 __FUNC_SIG(setRewardsDuration)         eq setRewardsDurationJump           jumpi

    // Revert if no functions match
    0x00 0x00 revert

    totalSupplyJump:
        TOTAL_SUPPLY()
    balanceOfJump:
        BALANCE_OF()
    lastTimeRewardApplicableJump:
        LAST_TIME_REWARD_APPLICABLE()
    rewardPerTokenJump:
        REWARD_PER_TOKEN()
    earnedJump:
        EARNED()
    getRewardForDurationJump:
        GET_REWARD_FOR_DURATION()
    stakeJump:
        LOCK()
        STAKE()
        finalize jump
    // withdrawJump:
    //     LOCK()
    //     WITHDRAW()
    //     finalize jump
    // getRewardJump:
    //     LOCK()
    //     GET_REWARD()
    //     finalize jump
    // exitJump:
    //     EXIT()
    // notifyRewardAmountJump:
    //     NOTIFY_REWARD_AMOUNT()
    recoverERC20Jump:
        RECOVER_ERC20()
    // setRewardsDurationJump:
    //     SET_REWARDS_DURATION()
    
    finalize:
        UNLOCK()
        stop
}